//!
//! Module for generating code for the consumer side of the ffi.
//!
//! Libraries that want to generate an interface for the FFI consumer (i.e., the language on the
//! other side of the boundary) must do the following:
//! 1. Add `ffi_common` to `[build-dependencies]` in `Cargo.toml`.
//! 1. Set the environment variable `FFI_CONSUMER_ROOT_DIR` to the path you want the consumer files
//! written at (it doesn't have to exist as long as it's valid; we'll create any necessary
//! directories on the way). We'll write the consumer files for each crate to a subdirectory using
//! the crate's package name.
//! 1. If you need a common framework imported into the generated code (for example, you may want to
//! put the generated primitives and other FFI glue code in one framework, but put each crate's
//! generated consumer code in its own consumer framework to avoid having a single massive
//! interface), you can specify that common framework with the environment variable
//! `"FFI_COMMON_FRAMEWORK"`.
//! 1. Create a `build.rs` file at the root of the crate with the following:
//! ```ignore
//! fn main() {
//!     let consumer_out_dir = match option_env!("FFI_CONSUMER_ROOT_DIR") {
//!         Some(dir) => dir.to_string(),
//!         None => std::env::var("OUT_DIR").expect("OUT_DIR will always be set by cargo."),
//!     };
//!     ffi_common::consumer::write_consumer_foundation(&consumer_dir, "swift")
//!         .expect("Unable to write consumer files");
//! }
//! ```
//!

#![allow(clippy::module_name_repetitions)]

use heck::CamelCase;
use proc_macro_error::{ResultExt, abort};
use syn::{Attribute, spanned::Spanned};

mod error;
mod primitives_conformance;

pub mod consumer_enum;
pub mod consumer_fn;
pub mod consumer_impl;
pub mod consumer_struct;
pub use error::Error;

/// A warning to add to the top of each file. Could add a date or customize the comment format if we
/// ever want to.
///
const HEADER: &str =
    "/// This was generated by the Rust `ffi_consumer` crate. Don't modify this manually.";

/// Tab size for indenting generated consumer code.
///
const TAB_SIZE: usize = 4;

/// Call this to write protocols and primitive conformance to those protocols to `consumer_dir`.
///
/// Note: If `consumer_dir` does not exist, it will be created (along with any missing parent
/// directories).
///
/// # Errors
///
/// Returns an error if we fail to read any of the supporting language files, or to write any of the
/// conformance files.
///
pub fn write_consumer_foundation(consumer_dir: &str, language: &str) -> Result<(), Error> {
    let consumer_dir = format!("{}/common", consumer_dir);
    let consumer_dir = super::create_consumer_dir(&consumer_dir)?;
    write_support_files(consumer_dir, language)?;
    write_primitive_conformances(consumer_dir)?;
    Ok(())
}

/// Converts a slice of doc comment attributes to a string of correctly formatted consumer comments.
/// 
/// `attrs` must be doc comments, or this will abort the proc macro.
/// `indentation_level` should be the number of levels that the type on this comment is nested. It
/// will be multiplied by `TAB_SIZE`.
/// 
/// Note that the returned `String` ends in a newline, so you don't need to (and shouldn't) push an
/// additional newline before pushing the consumer content.
/// 
fn consumer_docs_from(attrs: &[Attribute], indentation_level: usize) -> String {
    let mut docs = attrs
        .iter()
        .filter_map(|attr| {
            if let syn::Meta::NameValue(meta) = attr.parse_meta().expect_or_abort("Cannot parse meta for doc comment.") {
                if let syn::Lit::Str(lit) = meta.lit {
                    let doc = lit.value();
                    if doc.is_empty() {
                        return None;
                    }
                    return Some(doc);
                }
            }
            abort!(attr.span(), "Unexpected meta for doc comment attribute.")
        })
        .map(|doc| format_doc(&doc, indentation_level))
        .collect::<Vec<String>>()
        .join("\n");
    if !docs.is_empty() { docs.push('\n') }
    docs
}

fn format_doc(doc: &str, indentation_level: usize) -> String {
    if indentation_level == 0 {
        format!("///{}", doc)
    } else {
        format!(
            "{spacer:length$}///{doc}",
            spacer = " ",
            length = TAB_SIZE * indentation_level,
            doc = doc
        )
    }
}

/// Reads the protocol file for `language` and writes it to `consumer_dir/FFIProtocols.language`.
///
/// This is a file in the consumer's language that contains any generic or non-type-specific
/// implementations needed for FFI support.
///
fn write_support_files(consumer_dir: &str, language: &str) -> Result<(), Error> {
    let crate_root = env!("CARGO_MANIFEST_DIR");
    let support_files = format!("{}/support/{}", crate_root, language);

    std::fs::read_dir(support_files)?.try_for_each(|entry| -> Result<(), Error> {
        let entry = entry?;
        let file_data: String = [HEADER, &std::fs::read_to_string(entry.path())?].join("\n\n");
        std::fs::write(
            format!("{}/{}", &consumer_dir, entry.file_name().into_string()?),
            file_data,
        )
        .map_err(Error::from)
    })
}

/// Write protocol conformance for all the supported primitive types to files in `consumer_dir`.
///
fn write_primitive_conformances(consumer_dir: &str) -> Result<(), std::io::Error> {
    [
        "bool", "u8", "u16", "u32", "u64", "i8", "i16", "i32", "i64", "f32", "f64",
    ]
    .iter()
    .try_for_each(|native_type| {
        let consumer_type = crate::consumer_type_for(native_type, false);
        // Note: This is only accurate for Swift primitives, whose FFI and consumer types happen to
        // match. Don't assume consumer_type == ffi_type for non-primitive types, or for primitives
        // in other languages.
        let ffi_type = &consumer_type;
        let conformance_file: String = [
            HEADER,
            &primitives_conformance::generate(native_type, ffi_type, &consumer_type),
        ]
        .join("\n\n");
        std::fs::write(
            format!("{}/{}.swift", consumer_dir, consumer_type),
            conformance_file,
        )
    })
}

/// Describes the behaviors required for generating a consumer type.
///
pub trait ConsumerType {
    /// The name of this type (used for generating the consumer file name).
    ///
    fn type_name(&self) -> String;

    /// The type definition.
    /// 
    /// This should not include leading or trailing newlines.
    ///
    fn type_definition(&self) -> Option<String>;

    /// The implementation of the `NativeData` protocol.
    /// 
    /// This should not include leading or trailing newlines.
    /// 
    fn native_data_impl(&self) -> String;

    /// The implementation of the `FFIArray` protocol.
    /// 
    /// This should not include leading or trailing newlines.
    ///
    fn ffi_array_impl(&self) -> String;

    /// The implementation of the `NativeArrayData` protocol.
    /// 
    /// This should not include leading or trailing newlines.
    ///
    fn native_array_data_impl(&self) -> String;

    /// The implementation for handling optional instances of this type.
    /// 
    /// This should not include leading or trailing newlines.
    ///
    fn option_impl(&self) -> String;

    /// Additional imports for the consumer side that this type requires.
    ///
    fn consumer_imports(&self) -> &[syn::Path];
}

/// Helper for turning any type that implements `ConsumerType` into an output `String`.
///
/// This trait is implemented for any type that implements `ConsumerType`, so there's no reason to
/// implement this directly; instead, you probably want something like `std::fmt::Display` or
/// `From<YourType> for String`.
///
pub trait ConsumerOutput {
    /// The `String` to write to a file that defines this type and its behaviors for the consumer.
    ///
    fn write_output(&self, out_dir: &str);
}

impl<C> ConsumerOutput for &C
where
    C: ConsumerType,
{
    fn write_output(&self, out_dir: &str) {
        let mut contents = vec![header_and_imports(self.consumer_imports())];
        if let Some(type_def) = self.type_definition() {
            contents.push(type_def);
        }
        contents.push(self.native_data_impl());
        contents.push(self.ffi_array_impl());
        contents.push(self.native_array_data_impl());
        contents.push(self.option_impl());
        let file_name = format!("{}.swift", self.type_name());
        crate::write_consumer_file(&file_name, contents.join("\n\n"), out_dir)
            .unwrap_or_else(|err| proc_macro_error::abort!("Error writing consumer file: {}", err));
    }
}

/// Turns a path segment into a camel cased string.
///
/// # Errors
///
/// Returns an error if `segment` is `None`.
///
fn get_segment_ident(segment: Option<&syn::PathSegment>) -> &syn::Ident {
    match segment {
        Some(segment) => &segment.ident,
        None => proc_macro_error::abort!(segment.span(), "Missing path segment"),
    }
}

/// Turns a slice of paths into a vec of consumer import statements
///
/// # Errors
///
/// Returns an error if any element in `paths` has zero segments.
///
fn build_imports(paths: &[syn::Path]) -> Vec<String> {
    paths
        .iter()
        .map(|path| {
            let crate_name = get_segment_ident(path.segments.first())
                .to_string()
                .to_camel_case();
            let type_name = get_segment_ident(path.segments.last())
                .to_string()
                .to_camel_case();
            format!("import class {}.{}", crate_name, type_name)
        })
        .collect()
}

fn header_and_imports(additional_imports: &[syn::Path]) -> String {
    let mut output = HEADER.to_string();
    output.push_str("\n\n");
    output.push_str(&option_env!("FFI_COMMON_FRAMEWORK")
        .map(|f| format!("import {}", f))
        .unwrap_or_default());

    if !additional_imports.is_empty() {
        output.push('\n');
        output.push_str(&build_imports(additional_imports).join("\n"));
    }

    output
}
